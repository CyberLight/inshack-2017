#!/usr/bin/python3
import re, random, hashlib, requests, os, stat, subprocess
import zipfile

zip_url = "https://drive.google.com/uc?export=download&id=0BzPQ2skYzQgeWThlX2VTd28ybUU"
testing = False

bs_sign = b'.SGS'
bs_code = b'.code'
bs_data = b'.data'


def alive():
    # retrieve content
    if testing:
        with open(os.path.dirname(__file__) + '/../public-files/secure-garden-shed-v2.zip', 'rb') as f:
            content = f.read()
    else:
        response = requests.get(zip_url)
        content = response.content
    # verify sha256 checksum
    content_sha256_returned = hashlib.sha256(content).hexdigest()
    if content_sha256_returned != "49e9be3f5f3b371b3e618f345413affcd1ba49c22c1e9b2fb438845ccd0a5b5f":
        return None, None, False
    with open('/tmp/my2.zip', 'wb') as f:
        f.write(content)
    zip_ref = zipfile.ZipFile('/tmp/my2.zip', 'r')
    os.system('mkdir /tmp/my2')
    zip_ref.extractall('/tmp/my2')
    zip_ref.close()
    with open('/tmp/my2/lock.sgsc', 'rb') as f:
        content = f.read()
    with open('/tmp/my2/sgs-exec-release-p', 'rb') as f:
        binary = f.read()
    os.system('rm -rf /tmp/my2*')
    return binary, content, True


def exploitable(binary, content):
    # patch lock file
    c_off = content.index(bs_code) + len(bs_code)
    patched = content[0:c_off]
    patched += b'\x70'
    patched += content[c_off+1:]
    # write files to /tmp
    assert(hashlib.sha256(patched).hexdigest() == "c77cc27f7fb186a9eb52eb558785dc4e1893eca8abd681305dda22abe022a436")
    # Launching a 32bits binary on docker does not work out of the box,
    # so we're just going to return True, see bellow for complete exploitation
    # and see ../writeup.md for explanation
    return True

    with open('/tmp/patched.sgsc', 'wb') as f:
        f.write(patched)
    with open('/tmp/sgs-exec', 'wb') as f:
        f.write(binary)
    os.chmod('/tmp/sgs-exec', stat.S_IRWXU)

    # execute and retrieve flag
    try:
        subprocess.check_output(['/tmp/sgs-exec', '/tmp/patched.sgsc'])
    except subprocess.CalledProcessError as e:
        if b'INSA{' in e.output:
            return True
    return False

if __name__ == "__main__":
    binary, content, is_alive = alive()
    print(is_alive and exploitable(binary, content))
